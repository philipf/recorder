Of course. Here is a detailed project blueprint and a series of incremental prompts for a code-generation LLM to build the Offline Voice Recorder application.

### Project Blueprint & Development Strategy

The project will be built incrementally, ensuring each step results in a functional, testable piece of the application. The core philosophy is to build the data layer first, then the core functionality, and finally layer on user interactions and polish.

-----

### **Phase 1: Foundation (Structure and Data)**

This phase establishes the basic visual structure and the underlying data storage mechanism.

  * **Step 1.1: HTML Structure:** Create the main HTML file with all necessary containers and elements for the UI, but without any dynamic behavior.
  * **Step 1.2: Basic CSS Layout:** Apply fundamental CSS to create the single-page layout, position the control area and the recordings list, and set basic typography and colors.
  * **Step 1.3: IndexedDB Initialization:** In JavaScript, create a helper module to handle all interactions with IndexedDB. The initial step will be to create a function that opens the database and creates the 'recordings' object store if it doesn't exist.
  * **Step 1.4: Displaying Recordings:** Create the function that reads all recordings from IndexedDB and dynamically renders them into the list on the page. This includes handling the "empty state" message.

### **Phase 2: Core Functionality (Recording)**

This phase introduces the primary feature: audio recording.

  * **Step 2.1: Basic Recording Logic:** Implement the JavaScript to request microphone access using `navigator.mediaDevices.getUserMedia`.
  * **Step 2.2: Start/Stop Recording:** Wire up the "Start" and "Stop" buttons. Use the `MediaRecorder` API to capture audio into a `Blob`.
  * **Step 2.3: Saving to Database:** Integrate the recording logic with the IndexedDB helper. When a recording is stopped, save the audio `Blob` along with metadata (default title, duration, creation date) to the database and refresh the recordings list.
  * **Step 2.4: UI State and Timer:** Implement the visual feedback for recording. This includes swapping the main button for the control panel, displaying a live-updating timer (MM:SS), and ensuring the UI reverts correctly on stop.

### **Phase 3: Interaction & Management**

This phase adds the features required to manage the saved recordings.

  * **Step 3.1: Delete Recording:** Implement the delete functionality. This involves adding event listeners to delete buttons, showing a confirmation modal, removing the entry from IndexedDB, and updating the UI.
  * **Step 3.2: Download Recording:** Implement the download functionality, allowing the user to save the `.webm` file to their local machine.
  * **Step 3.3: Rename Recording:** Implement the in-place editing for the recording title. This involves swapping a text element for an input field on click and saving the change to IndexedDB on 'Enter' or 'blur'.
  * **Step 3.4: Pause/Resume:** Enhance the recording controls to include pause and resume functionality, ensuring the timer and `MediaRecorder` state are managed correctly.

### **Phase 4: Polish and Robustness**

This final phase adds cleanup logic and handles potential user and system errors.

  * **Step 4.1: Auto-Deletion Logic:** Implement the function that runs on app load to automatically find and delete any recordings older than 10 days.
  * **Step 4.2: Error Handling:** Add checks for browser support (`MediaRecorder`, `IndexedDB`) and microphone permission denial. Display clear, user-friendly messages for each error case.
  * **Step 4.3: Final CSS Polish:** Refine the CSS with improved styling, hover effects, and smooth transitions to create a polished final product.

-----

### LLM Prompts for Implementation

Here are the series of prompts designed for a code-generation LLM. Each prompt builds upon the code generated by the previous one.

-----

### **Prompt 1: HTML and CSS Foundation**

```text
Create the foundational files for an "Offline Voice Recorder" web application.

1.  **`index.html`**:
    * Set up the basic HTML5 document structure.
    * In the `<body>`, create a `<header>` for the recording controls. Inside it, include a main button with the ID `recordButton` and the text "Start Recording". Also include a `div` with the ID `recordingControls` which will be hidden initially. This div should contain a timer element with ID `timer` (default text "00:00"), a "Pause" button with ID `pauseButton`, and a "Stop" button with ID `stopButton`.
    * Below the header, create a `<main>` section.
    * Inside `<main>`, include a `<h2>` with the text "My Recordings".
    * Below the heading, create a `<ul>` with the ID `recordingsList` to hold the list of recordings.
    * Link to a `style.css` file and a `script.js` file (using `defer`).

2.  **`style.css`**:
    * Apply a basic dark theme and use a clean, sans-serif font.
    * Center the main content of the application on the page.
    * Style the `#recordButton` to be large and prominent.
    * Initially hide the `#recordingControls` div using `display: none;`.
    * Add a placeholder style for the `#recordingsList` to ensure it's visible.
    * Make sure the layout is clean and functional.

3.  **`script.js`**:
    * Add a comment placeholder: `// Application code will go here.`
```

-----

### **Prompt 2: IndexedDB Helper and Initial DOM Setup**

````text
Using the files from the previous step, let's set up the core JavaScript logic.

In `script.js`:
1.  **DOM Element References**: At the top of the file, get references to all the necessary DOM elements: `#recordButton`, `#recordingControls`, `#pauseButton`, `#stopButton`, `#timer`, and `#recordingsList`.

2.  **IndexedDB Helper**:
    * Create a variable `db` to hold the database connection.
    * Create a function `initDB()` that initializes the IndexedDB.
    * It should open a database named `voice_recorder_db` with version `1`.
    * In the `onupgradeneeded` event handler, create an object store named `recordings`.
    * The `recordings` object store should use `id` as its `keyPath` with `autoIncrement: true`.
    * Create an index on the `createdAt` field to allow for sorting by date.
    * Handle `onsuccess` and `onerror` events for the database opening request. On success, assign the database connection to the `db` variable and then call a new function `displayRecordings()`. On error, log the error to the console.

3.  **Initial Call**: Call `initDB()` when the script first loads.

4.  **Display Function Stub**: Create an empty function `displayRecordings()` for now. We will implement it in the next step. It should simply clear the contents of `recordingsList` and display a message if there are no recordings.

Modify the code to look like this:

```javascript
// At the top
const recordButton = document.getElementById('recordButton');
// ... other elements

let db;
// ... initDB function

// ... displayRecordings function stub
function displayRecordings() {
    recordingsList.innerHTML = '';
    const li = document.createElement('li');
    li.textContent = 'Your recordings will appear here.';
    recordingsList.appendChild(li);
}

// At the bottom
window.addEventListener('load', () => {
    initDB();
});
````

This ensures we have a non-functional but correctly structured starting point.

````

***

### **Prompt 3: Displaying Recordings from IndexedDB**

```text
Now, let's fully implement the `displayRecordings()` function in `script.js` to render the list of recordings stored in IndexedDB.

1.  **Modify `displayRecordings()`**:
    * Start by clearing the current content of `recordingsList`.
    * Create a transaction on the `recordings` object store in `'readonly'` mode.
    * Use the `getAll()` method to fetch all recording objects.
    * On the success of the `getAll()` request:
        * If the result array is empty, display the "Your recordings will appear here." message as before.
        * If there are recordings, reverse the array to sort them in reverse chronological order (newest first).
        * Iterate over the reversed array. For each `recording` object:
            * Create a `<li>` element. Add a `data-id` attribute set to the `recording.id`.
            * Inside the `<li>`, create a `<span>` with a class `recording-title` for the title. Set its text content to `recording.title`.
            * Create another `<span>` for the duration. Set its text to `recording.duration`.
            * Create a "Download" button (`<button>`) with a class `download-btn`.
            * Create a "Delete" button (`<button>`) with a class `delete-btn`.
            * Append all these elements to the `<li>`, and then append the `<li>` to the `recordingsList`.

2.  **CSS for the List**:
    * In `style.css`, add styles for the generated list items. Use flexbox to align the title, duration, and buttons on a single line. Add some spacing and basic styling for the buttons to make them look clickable.
````

-----

### **Prompt 4: Core Recording Logic (Start/Stop and Saving)**

```text
Let's implement the main recording functionality. We will wire up the "Start" and "Stop" buttons to use the `MediaRecorder` API and save the result to IndexedDB.

In `script.js`:
1.  **State Variables**: At the top of the script, add variables to manage the recording state: `let mediaRecorder;`, `let audioChunks = [];`, `let recordingStartTime;`.

2.  **Start Recording Logic**:
    * Add a `click` event listener to `recordButton`.
    * Inside the listener:
        * Use `navigator.mediaDevices.getUserMedia({ audio: true })` to request microphone access.
        * In the `.then()` (success) block:
            * Set `recordingStartTime = new Date();`.
            * Create a new `MediaRecorder` instance from the received stream. Assign it to the `mediaRecorder` variable.
            * Call `mediaRecorder.start()`.
            * Implement the `mediaRecorder.ondataavailable` event handler. Inside it, push the event `data` to the `audioChunks` array.
            * Implement the `mediaRecorder.onstop` event handler. This is where we will save the recording:
                * Create a `Blob` from the `audioChunks` array with the type `'audio/webm'`.
                * Reset `audioChunks = [];`.
                * Calculate the duration. You can use `(new Date() - recordingStartTime) / 1000`. Format this into an MM:SS string.
                * Create a default title: `YYYY-MM-DD HH:MM - Recording`.
                * Create a new recording object: `{ title, duration, createdAt: new Date(), audio: blob }`.
                * Open a `'readwrite'` transaction on the `recordings` object store and `add` this new object.
                * On the transaction's `complete` event, call `displayRecordings()` to refresh the list.
            * Update the UI: hide `recordButton` and show `recordingControls`.
        * In the `.catch()` (error) block, log the error and perhaps show an alert to the user.

3.  **Stop Recording Logic**:
    * Add a `click` event listener to `stopButton`.
    * Inside the listener, simply call `mediaRecorder.stop()`.
    * Update the UI: show `recordButton` and hide `recordingControls`.
```

-----

### **Prompt 5: Adding the Timer and Pause/Resume Functionality**

```text
Let's enhance the recording experience by adding a live timer and the ability to pause and resume.

In `script.js`:
1.  **Timer State**: At the top, add variables for the timer: `let timerInterval;` and `let secondsElapsed = 0;`.

2.  **Timer Functions**:
    * Create a function `formatTime(seconds)` that takes a total number of seconds and returns a string in `MM:SS` format.
    * Create a function `startTimer()` that:
        * Clears any existing interval with `clearInterval(timerInterval)`.
        * Sets `secondsElapsed` based on the time since `recordingStartTime`.
        * Uses `setInterval` to increment `secondsElapsed` every second and update the `#timer` element's text content by calling `formatTime()`. Store the interval ID in `timerInterval`.
    * Create a function `stopTimer()` that clears the interval using `clearInterval(timerInterval)`.

3.  **Integrate Timer with Recording**:
    * In the `recordButton` click handler, after `mediaRecorder.start()`, call `startTimer()`.
    * In the `stopButton` click handler, before `mediaRecorder.stop()`, call `stopTimer()` and reset `secondsElapsed = 0`. Also, reset the timer display to "00:00".

4.  **Pause/Resume Logic**:
    * At the top, add a state variable: `let isPaused = false;`.
    * Add a `click` event listener to `pauseButton`.
    * Inside the listener:
        * If `isPaused` is `false`:
            * Call `mediaRecorder.pause()`.
            * Call `stopTimer()`.
            * Change `pauseButton.textContent` to "Resume".
            * Set `isPaused = true;`.
        * Else (if `isPaused` is `true`):
            * Call `mediaRecorder.resume()`.
            * Call `startTimer()`. Note: `startTimer` needs to be slightly adjusted. It should not reset `secondsElapsed` if resuming. We can pass the total elapsed time to it. *Correction*: The duration calculation needs to be smarter. Instead of `new Date() - recordingStartTime`, we need to track elapsed time separately. Let's adjust.
            * *Refined approach*: Keep `secondsElapsed` as the master counter. In `startTimer`, just run the interval that increments it. When pausing, stop the interval. When resuming, restart it. The final duration should be based on `secondsElapsed` when the recording is stopped.
            * Change `pauseButton.textContent` to "Pause".
            * Set `isPaused = false;`.

5.  **Update Duration Calculation**: In the `mediaRecorder.onstop` handler, use the final value of `secondsElapsed` to calculate the duration string instead of `new Date() - recordingStartTime`.
```

-----

### **Prompt 6: Implementing Delete, Download, and Rename**

```text
Now let's add the management features for the recordings: Delete, Download, and Rename. We will use event delegation on the `recordingsList`.

In `script.js`:
1.  **Event Delegation**: Add a single `click` event listener to the `recordingsList` element.

2.  **Inside the Listener**:
    * Check `if (event.target.classList.contains('delete-btn'))`.
        * If true, get the parent `<li>` element and its `data-id`.
        * Show a confirmation dialog: `if (confirm('Are you sure you want to delete this recording?'))`.
        * If confirmed, open a `'readwrite'` transaction, get the object store, and call `store.delete(Number(id))`.
        * On the transaction's `complete` event, call `displayRecordings()` to update the UI.

    * Check `if (event.target.classList.contains('download-btn'))`.
        * If true, get the parent `<li>` and its `data-id`.
        * Open a `'readonly'` transaction and get the recording from the store using `store.get(Number(id))`.
        * On the request's `success` event, you'll have the recording object.
        * Create a download link: use `URL.createObjectURL(recording.audio)` to create a URL for the blob. Create a temporary `<a>` element, set its `href` to this URL, set its `download` attribute to the `recording.title` (with a `.webm` extension), click it, and then revoke the object URL with `URL.revokeObjectURL()`.

    * Check `if (event.target.classList.contains('recording-title'))`.
        * If true, implement in-place renaming:
            * Get the `<span>` element that was clicked.
            * Create an `<input type="text">` element. Set its value to the current title.
            * Replace the `<span>` with the `<input>`.
            * Focus the input.
            * Add event listeners to the input for `blur` and `keydown`.
            * The handler for both events should trigger a `saveRename` function. Inside the handler, check if the key pressed was 'Enter' or if the event is 'blur'.
            * The `saveRename` function will: get the new title from the input's value, get the recording ID from the `<li>`'s `data-id`, update the record in IndexedDB, and then call `displayRecordings()` to re-render the list.
```

-----

### **Prompt 7: Auto-Deletion and Error Handling**

````text
This is the final functionality step. We will add the logic to clean up old recordings and handle potential errors gracefully.

In `script.js`:
1.  **Auto-Deletion Function**:
    * Create a new function `cleanupOldRecordings()`.
    * Inside it, calculate the timestamp for 10 days ago: `const tenDaysAgo = new Date().getTime() - (10 * 24 * 60 * 60 * 1000);`.
    * Open a `'readwrite'` transaction on the `recordings` store.
    * Use a cursor (`store.openCursor()`) to iterate through all records.
    * In the cursor's `success` handler, check if a cursor exists.
    * If it does, get the recording's `createdAt` date. If `recording.createdAt.getTime() < tenDaysAgo`, call `cursor.delete()`.
    * Call `cursor.continue()` to move to the next record.
    * When the cursor iteration is complete, call `displayRecordings()` to ensure the UI reflects any deletions.

2.  **Integrate Cleanup**: In the `initDB()` function, after the database is successfully opened (in the `onsuccess` handler), call `cleanupOldRecordings()`.

3.  **Browser Support Check**:
    * At the very top of the script, before any other code runs, add a check:
    ```javascript
    if (!window.MediaRecorder || !window.indexedDB) {
      alert("Your browser does not support the required features for this application. Please use a modern browser like Chrome or Firefox.");
      // Optionally, disable the record button here.
      recordButton.disabled = true;
    }
    ```

4.  **Microphone Permission Error Handling**:
    * In the `recordButton`'s click listener, modify the `.catch()` block for `getUserMedia`.
    * Instead of just logging the error, show a user-friendly alert: `alert('Microphone access was denied. You need to allow microphone access to create a recording.');`.

5.  **Storage Quota Error**:
    * In the `mediaRecorder.onstop` handler, where you add the new recording to the database, add an `onerror` handler to the transaction.
    * Inside the `onerror` handler, check `if (event.target.error.name === 'QuotaExceededError')`.
    * If it is, alert the user: `alert('Storage quota exceeded. Please free up some space by deleting old recordings.');`.
    * Be sure to call `event.preventDefault()` to prevent the browser's default error handling.
````